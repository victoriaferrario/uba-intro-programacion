## Guia repaso python from queue import Queue as Cola# EJERCICIO 1# problema stock productos (in stock cambios : seq⟨str × Z⟩) : seq⟨Z⟩ {# requiere: {Todos los elementos de stock cambios est ́an formados por un str no vac ́ıo y un entero ≥ 0.}# asegura: {res tiene como claves solo los primeros elementos de las tuplas de stock cambios (o sea, un producto).} asegura: {res tiene como claves todos los primeros elementos de las tuplas de stock cambios.}# asegura: {El valor en res de un producto es una tupla de cantidades. # Su primer elemento es la menor cantidad de ese producto en stock cambios y como segundo valor el mayor.}# }# stock_cambios: list[tuple[str,int]] = [("a",3),("b",4),("a",2),("b",4)]def stock_productos(stock_cambios: list[tuple[str,int]]) -> dict[str:tuple[int:int]]:    fluc_stock: dict[str:tuple[int:int]] = {}        for (producto, stock) in stock_cambios:        if producto in fluc_stock.keys():            if stock > fluc_stock[producto][1]:                fluc_stock[producto] = (fluc_stock[producto][0], stock)                            elif stock < fluc_stock[producto][0]:                fluc_stock[producto] = (stock, fluc_stock[producto][1])                    else:                        fluc_stock[producto] = (stock,0)                return fluc_stock# Ejercicio 2. Veterinaria - Filtrar c ́odigos de barra# El hijo del duen ̃o de la veterinaria, cuya actividad principal es ver tik toks, cree que los productos cuyos c ́odigos de barras# terminan en nu ́meros primos son especialmente auspiciosos y deben ser destacados en la tienda. Luego de convencer a su padre de esta idea, solicita una funci ́on en Python que facilite esta gesti ́on. Se pide implementar una funci ́on que, dada una secuencia de enteros, cada uno representando un c ́odigo de barras de un producto, cree y devuelva una nueva lista que contenga u ́nicamente aquellos nu ́meros de la lista original cuyos u ́ltimos tres d ́ıgitos formen un nu ́mero primo (por ejemplo, 101, 002 y 011).# Nota: Un nu ́mero primo es aquel que solo es divisible por s ́ı mismo y por 1. Algunos ejemplos de nu ́meros primos de hasta tres d ́ıgitos son: 2, 3, 5, 101, 103, 107, etc.codigos_barra = [4216101, 532320, 103, 5235107, 555, 200, 640, 4003]def filtrar_codigo_primos(codigos_barra:list[int]) -> list[int]:    numeros_magicos: list[int] = []    for i in codigos_barra:         codigo =  str(i)        codigo_f = codigo[len(codigo)-3] + codigo[len(codigo)-2] + codigo[len(codigo)-1]                if es_primo(int(codigo_f)):             numeros_magicos.append(i)                return numeros_magicos    def es_primo(n: int) -> bool:    mult = 1    i = 2    while i < n and mult == 1:        if n % i == 0 :            mult = 2        i += 1     return mult == 1 # Ejercicio 3. Veterinaria - Flujo de pacientes# Con el objetivo de organizar el flujo de pacientes, en una veterinaria se anotan los tipos de mascotas que van ingresando# al local. Se necesita identificar las consultas que involucran solo a perros y gatos. Por eso, se decide desarrollar una funci ́on en Python que encuentre la secuencia m ́as larga de consultas consecutivas que solo contenga los tipos de mascota ”perro” o ”gato”. Se pide implementar una funci ́on que, dada una secuencia de strs, que representan los tipos de animales atendidos, devuelva el#  ́ındice donde comienza la subsecuencia m ́as larga que cumpla con estas condiciones.def subsecuencia_mas_larga(tipos_pacientes_ingresados: list[str]) -> int:    contador: int = 0    indice_primer_el: int = 0    longitud_mayor:int = 0    indice_mayor:int = 0        for i in range(len(tipos_pacientes_ingresados)):        if tipos_pacientes_ingresados[i] != "perro" and tipos_pacientes_ingresados[i] != "gato":            if contador >= longitud_mayor:                longitud_mayor = contador                indice_mayor = indice_primer_el            contador = 0        elif contador == 0 :            contador += 1             indice_primer_el = i        else: # contador es > 0 y estas adentro             contador += 1                if contador >= longitud_mayor:        longitud_mayor = contador        indice_mayor = indice_primer_el            return indice_mayor# tipos_pacientes_ingresado = ["perro","gato","pato","caballo","perro","gato","gato"]# subsecuencia_mas_larga(tipos_pacientes_ingresado)# Cola en el Banco# En el banco ExactaBank los clientes hacen cola para ser atendidos por un representante. Los clientes son representados por# las tuplas (nombre, tipo afiliado) donde la primera componente es el nombre y el tipo afiliado puede ser ”comu ́n” o ”vip”.# Se nos pide implementar una funci ́on en python que dada una cola de clientes del banco, devuelva una nueva cola con los mismos clientes pero en donde los clientes vip est ́an primero que los clientes comunes manteniendo el orden original de los clientesdef reordenar_cola_organizando(filaClientes: Cola[tuple[str,str]]) -> Cola[str]:    fila_vip: Cola = Cola()    fila_plebe: Cola = Cola()    fila_copia: Cola = Cola()        while not filaClientes.empty():        persona = filaClientes.get()        if persona[1] == "vip":            fila_vip.put(persona[0])        else:             fila_plebe.put(persona[0])                    fila_copia.put(persona)        while not fila_plebe.empty():        plebe = fila_plebe.get()        fila_vip.put(plebe)        filaClientes = fila_copia    print(filaClientes.empty())            return fila_vipfilaClientes: Cola[tuple[str,str]] = Cola()filaClientes.put(("t", "comun"))filaClientes.put(("e", "vip"))filaClientes.put(("a", "comun"))filaClientes.put(("m", "vip"))filaClientes.put(("o", "comun"))filaClientes.put(("s", "vip"))reordenar_cola_organizando(filaClientes)                            